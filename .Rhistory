dplyr::group_by_at(.vars = dplyr::vars(all_of(grouping_variables))) %>%
dplyr::summarise(.groups = "drop_last",
min.lwr = quantile(est_min)[3]- (diff(quantile(est_min)[c(2,4)])*ss.IQR)  ,
min.upr = quantile(est_min)[3]+ (diff(quantile(est_min)[c(2,4)])*ss.IQR)  ,
max.lwr = quantile(est_max)[3]- (diff(quantile(est_max)[c(2,4)])*ss.IQR)  ,
max.upr = quantile(est_max)[3]+ (diff(quantile(est_max)[c(2,4)])*ss.IQR)  )
power_results3<-power_test %>%
# dplyr::filter(sig_int == 1) %>%
dplyr::group_by_at(.vars = dplyr::vars(all_of(grouping_variables))) %>%
dplyr::summarise(.groups = "drop_last",
x1_est_mean   =mean(x1_est),
x2_est_mean = mean(x2_est),
x1x2_est_mean = mean(x1x2_est),
r_x1_y_mean = mean(r_x1_y),
r_x2_y_mean = mean(r_x2_y),
r_x1_x2_mean = mean(r_x1_x2),
r_y_x1x2_mean = mean(r_y_x1x2),
r_x1_x1x2_mean = mean(r_x1_x1x2),
r_x2_x1x2_mean = mean(r_x2_x1x2)    )
results<-merge(power_results,power_results2,all = T)
if(detailed_results == TRUE){results<-merge(results,power_results3,all=T)}
if(full_simulation == TRUE){results<-list(results = results, simulation=power_test)  }
power_out<-results
}
if(!is.null(cl)){
parallel::stopCluster(clus)
foreach::registerDoSEQ()
}
out_dims<-t(mapply(dim,power_out))
u_dims<-unique(out_dims)
if(dim(u_dims)[2] == 2){
same_rows<- apply(out_dims,1,function(X) {identical(X,u_dims[1,])})
main_result<-as.data.frame(matrix(unlist(t(mapply(c,power_out[same_rows]))),ncol =  5))
colnames(main_result)<-colnames(power_out[[1]])
same_rows<- apply(out_dims,1,function(X) {identical(X,u_dims[2,])})
full_result<-as.data.frame(matrix(unlist(t(mapply(c,power_out[same_rows]))),ncol =  34))
colnames(full_result)<-colnames(power_out[[length(power_out)]])
result_out<-list(main_result,full_result)
}
if(dim(u_dims)[2] == 1){
same_rows<- apply(out_dims,1,function(X) {identical(X,u_dims[1,])})
main_result<-as.data.frame(matrix(unlist(t(mapply(c,power_out[same_rows]))),ncol =  5))
colnames(main_result)<-colnames(power_out[[1]])
result_out<-main_result
}
result_out
dim(u_dims)[2] == 1
u_dims
out_dims
power_out
dim,power_out
is.list(power_out)
t(mapply(dim,power_out))
dim(power_out)
out_dims
u_dims<-unique(out_dims)
dim(u_dims)
results
power_out
unlist(power_out)
as.data.frame(power_out)
t2<-list(power_out,power_out)
t(mapply(dim,t2))
out_dims
is.null(out_dims)
out_dims
which(is.null(out_dims))
t(mapply(is.null,power_out))
t(mapply(is.null,out_dims))
out_na<-sum(t(mapply(is.null,out_dims)))>0
out_dims<-t(mapply(dim,t2))
out_na<-sum(t(mapply(is.null,out_dims)))>0
out_dims<-t(mapply(dim,power_out))
out_na<-sum(t(mapply(is.null,out_dims)))>0
u_dims<-unique(out_dims)
out_na == T
result_out<-as.data.frame(power_out)
result_out
out.mat<-foreach::foreach(i = 1:n.iter,.combine = 'rbind',
.packages = c('dplyr','MASS'),
.export=c("test_interaction","generate_interaction")) %dopar% {
simulation <- test_interaction(data =
generate_interaction(N = settings$N[1],
r.x1.y = settings$r.x1.y[1],
r.x2.y = settings$r.x2.y[1],
r.x1x2.y= settings$r.x1x2.y [1],
r.x1.x2  = settings$r.x1.x2[1],
mean.x1 = settings$mean.x1[1],
sd.x1 = settings$sd.x1[1],
mean.x2 = settings$mean.x2[1],
sd.x2 = settings$sd.x2[1],
mean.y = settings$mean.y[1],
sd.y = settings$sd.y[1]
#sd.x1x2 = settings$sd.x1x2[1],
#r.x1.x1x2=settings$r.x1.x1x2[1],
#r.x2.x1x2=settings$r.x2.x1x2[1],
#binary.x1 = settings$ binary.x1[1],
#binary.x2 = settings$ binary.x2[1]
),
alpha = settings$alpha[1],
q = settings$q[1])
return(simulation)
}
#out.mat<-t(out.mat)
out.mat<-cbind(out.mat,settings[1,],row.names=NULL)
out.cols<-colnames(out.mat)
out.mat<-as.data.frame(matrix(unlist(out.mat),nrow = n.iter))
colnames(out.mat)<-out.cols
power_test <- out.mat
settings<-power_test[,c(22:34)]
dimnum<- sapply(X=c(1:dim(settings)[2]), FUN=function(x){length(table(settings[,x]))})
grouping_variables<-colnames(settings)[dimnum>1]
remove.packages("InteractionPoweR")
.rs.restartR()
setwd("~/InteractionPoweR")
document()
setwd("..")
install("InteractionPoweR")
library(InteractionPoweR)
?generate_interaction
library(usethis)
use_readme_rmd()
library(rmarkdown)
install.packages("rmarkdown")
use_readme_rmd()
setwd("~/InteractionPoweR")
use_readme_rmd()
use_readme_rmd(open = rlang::is_interactive())
remove.packages("InteractionPoweR")
use_readme_rmd(open = rlang::is_interactive())
s
remove.packages("InteractionPoweR")
.rs.restartR()
setwd("~/InteractionPoweR")
document()
document()
document()
document()
document()
document()
document()
document()
document()
use_readme_rmd(open = rlang::is_interactive())
remove.packages("InteractionPoweR")
.rs.restartR()
setwd("~/InteractionPoweR")
document()
setwd("..")
install("InteractionPoweR")
tic()
test_power<-power_interaction_beta(n.iter = 1000,N = seq(20,400,by=20),cl = 6,
r.x1.y = .2,r.x2.y = .1,r.x1x2.y = .2,r.x1.x2 = .2)
toc()
library(InteractionPoweR)
library(tictoc)
tic()
test_power<-power_interaction_beta(n.iter = 1000,N = seq(20,400,by=20),cl = 6,
r.x1.y = .2,r.x2.y = .1,r.x1x2.y = .2,r.x1.x2 = .2)
test_power<-power_interaction(n.iter = 1000,N = seq(20,400,by=20),cl = 6,
r.x1.y = .2,r.x2.y = .1,r.x1x2.y = .2,r.x1.x2 = .2)
toc()
test_power
power_curve(power_data = test_power,goal_power = .95)
plot_power_curve(power_data = test_power,goal_power = .95)
plot_simple_slope(power_data = test_power)
power_estimate(power_data = test_power,x = "N",power_target = ..95)
power_estimate(power_data = test_power,x = "N",power_target = .95)
test_power
power_estimate(power_data = test_power,x = "N",power_target = .8)
power_estimate(power_data = test_power,x = "N",power_target = .5)
power_estimate(power_data = test_power,x = "N",power_target = 0.95)
plot_interaction(data = generate_interaction(N = 300, r.x1.y = .2,r.x2.y = .1,r.x1x2.y = .2,r.x1.x2 = .2,q=2))
plot_interaction(q = 2,data = generate_interaction(N = 300, r.x1.y = .2,r.x2.y = .1,r.x1x2.y = .2,r.x1.x2 = .2))
power_data<-test_power
x<-"N"
power_target=.95
power_data2<-power_data[,c(1: which(colnames(power_data) == "pwr"))]
View(power_data2)
data_dim<-dim(power_data2)[2]
x_col<-which(colnames(power_data2) == x)
pwr_col<-which(colnames(power_data2) == "pwr")
other_cols<-colnames(power_data2)[-c(x_col,pwr_col)]
data_dim==2
if(data_dim==2){power_data2$temp<-1}
# if(dim(power_data2)[2] > 2){
# power_levels<-as.numeric(names(table(power_data2[,-c(which(colnames(power_data2) == "pwr"),x_col)])))
power_levels<-  unique(expand.grid(power_data2[,-c(which(colnames(power_data2) == "pwr"),x_col)]))
power_levels
rownames(power_levels)<-NULL
#colnames(power)
if(data_dim==2){colnames(power_levels)<-"temp"}
if(dim(power_data2)[2] > 2){
colnames(power_levels) <- other_cols
}
power_out_final<-as.data.frame(power_levels)
power_out_final
#colnames(power_out)<- colnames(power_data2[,-c(which(colnames(power_data2) == "pwr"),x_col)])
power_out<-power_out_final
power_out_final$estimate<-0
power_out_final
#print(p)
#filters=paste(  colnames(power_out),"==",power_out[p,])
filters=paste( "near(",colnames(power_levels),",",power_levels[p,],",tol=10^-10)")
power_test<-dplyr::filter(power_data2, !!!rlang::parse_exprs(paste(filters, collapse = ";")))
power_test<-as.data.frame(power_test)
dim(power_test)[1]
dim(power_test)[1] > 0
power_test$x<-power_test[,x_col]
power_test$x2<-power_test$x ^2
power_test$x3<-power_test$x ^3
power_test$lnx<-log(power_test$x)
power_test[power_test=="-Inf"]<-NA
power_test<-na.omit(power_test)
fit1=chngpt::chngptm (formula.1=pwr~1, formula.2=~x+x2, data = power_test, type="M20", ncpus = 1,
family="gaussian",ci.bootstrap.size = 0)
power_test
test_power
power_data<-test_power
power_data
View(power_data)
power_data2<-power_data[,c(1: which(colnames(power_data) == "pwr"))]
power_data2
data_dim<-dim(power_data2)[2]
x_col<-which(colnames(power_data2) == x)
pwr_col<-which(colnames(power_data2) == "pwr")
x_col
other_cols<-colnames(power_data2)[-c(x_col,pwr_col)]
other_cols
data_dim
if(data_dim==2){power_data2$temp<-1}
power_data2
# if(dim(power_data2)[2] > 2){
# power_levels<-as.numeric(names(table(power_data2[,-c(which(colnames(power_data2) == "pwr"),x_col)])))
power_levels<-  unique(expand.grid(power_data2[,-c(which(colnames(power_data2) == "pwr"),x_col)]))
power_levels
rownames(power_levels)<-NULL
#colnames(power)
if(data_dim==2){colnames(power_levels)<-"temp"}
if(dim(power_data2)[2] > 2){
colnames(power_levels) <- other_cols
}
power_out_final<-as.data.frame(power_levels)
#colnames(power_out)<- colnames(power_data2[,-c(which(colnames(power_data2) == "pwr"),x_col)])
power_out<-power_out_final
power_out_final$estimate<-0
dim(power_out)[1]
#print(p)
#filters=paste(  colnames(power_out),"==",power_out[p,])
filters=paste( "near(",colnames(power_levels),",",power_levels[p,],",tol=10^-10)")
power_test<-dplyr::filter(power_data2, !!!rlang::parse_exprs(paste(filters, collapse = ";")))
power_test<-as.data.frame(power_test)
dim(power_test)[1] > 0)
dim(power_test)[1] > 0
power_test
power_data2
power_test<-dplyr::filter(power_data2, !!!rlang::parse_exprs(paste(filters, collapse = ";")))
power_test
power_test<-dplyr::filter(power_data2, !!!rlang::parse_exprs(paste(filters, collapse = ";")))
#print(p)
#filters=paste(  colnames(power_out),"==",power_out[p,])
filters=paste( "near(",colnames(power_levels),",",power_levels[p,],",tol=10^-10)")
power_test<-dplyr::filter(power_data2, !!!rlang::parse_exprs(paste(filters, collapse = ";")))
#print(p)
#filters=paste(  colnames(power_out),"==",power_out[p,])
filters=paste( "near(",colnames(power_levels),",",power_levels[p,],",tol=10^-10)")
p<-1
#print(p)
#filters=paste(  colnames(power_out),"==",power_out[p,])
filters=paste( "near(",colnames(power_levels),",",power_levels[p,],",tol=10^-10)")
power_test<-dplyr::filter(power_data2, !!!rlang::parse_exprs(paste(filters, collapse = ";")))
power_test<-as.data.frame(power_test)
power_test
dim(power_test)[1] > 0
power_levels
# if(dim(power_data2)[2] > 2){
# power_levels<-as.numeric(names(table(power_data2[,-c(which(colnames(power_data2) == "pwr"),x_col)])))
power_levels<-  unique(expand.grid(power_data2[,-c(which(colnames(power_data2) == "pwr"),x_col)]))
power_levels
rownames(power_levels)<-NULL
#colnames(power)
if(data_dim==2){colnames(power_levels)<-"temp"}
if(dim(power_data2)[2] > 2){
colnames(power_levels) <- other_cols
}
power_out_final<-as.data.frame(power_levels)
#colnames(power_out)<- colnames(power_data2[,-c(which(colnames(power_data2) == "pwr"),x_col)])
power_out<-power_out_final
power_out_final$estimate<-0
power_out_final
power_levels
power_data2
rlang::parse_exprs(paste(filters, collapse = ";")
)
filters
power_levels
power_levels
data_dim==2
power_data2<-power_data[,c(1: which(colnames(power_data) == "pwr"))]
data_dim<-dim(power_data2)[2]
x_col<-which(colnames(power_data2) == x)
pwr_col<-which(colnames(power_data2) == "pwr")
other_cols<-colnames(power_data2)[-c(x_col,pwr_col)]
if(data_dim==2){power_data2$temp<-1}
# if(dim(power_data2)[2] > 2){
# power_levels<-as.numeric(names(table(power_data2[,-c(which(colnames(power_data2) == "pwr"),x_col)])))
power_levels<-  unique(expand.grid(power_data2[,-c(which(colnames(power_data2) == "pwr"),x_col)]))
power_levels
rownames(power_levels)<-NULL
#colnames(power)
if(data_dim==2){colnames(power_levels)<-"temp"}
power_levels
dim(power_data2)[2] > 2
dim(power_data2)
#colnames(power)
if(data_dim==2){colnames(power_levels)<-"temp"
}  else{
#if(dim(power_data2)[2] > 2){
colnames(power_levels) <- other_cols
}
power_levels
power_out_final<-as.data.frame(power_levels)
#colnames(power_out)<- colnames(power_data2[,-c(which(colnames(power_data2) == "pwr"),x_col)])
power_out<-power_out_final
power_out_final$estimate<-0
#print(p)
#filters=paste(  colnames(power_out),"==",power_out[p,])
filters=paste( "near(",colnames(power_levels),",",power_levels[p,],",tol=10^-10)")
filters
power_test<-dplyr::filter(power_data2, !!!rlang::parse_exprs(paste(filters, collapse = ";")))
power_test<-as.data.frame(power_test)
dim(power_test)[1] > 0
power_test$x<-power_test[,x_col]
power_test$x2<-power_test$x ^2
power_test$x3<-power_test$x ^3
power_test$lnx<-log(power_test$x)
power_test[power_test=="-Inf"]<-NA
power_test<-na.omit(power_test)
fit1=chngpt::chngptm (formula.1=pwr~1, formula.2=~x+x2, data = power_test, type="M20", ncpus = 1,
family="gaussian",ci.bootstrap.size = 0)
# can we compare model fits?
fit1c=chngpt::chngptm (formula.1=pwr~1, formula.2=~x+x2+x3, data = power_test, type="M20", ncpus = 1,
family="gaussian",ci.bootstrap.size = 0)
fit1b=chngpt::chngptm (formula.1=pwr~1, formula.2=~lnx, data = power_test, type="M10", ncpus = 1,
family="gaussian",ci.bootstrap.size = 0)
changepoint<-max(c(fit1$chngpt,fit1c$chngpt,exp(fit1b$chngpt)))
power_test2<-dplyr::filter(power_test, x<= changepoint)
fit2<-lm(pwr~x + x2,data = power_test2)
fit3<-lm(pwr~x + x2 + x3,data = power_test2)
fit4<-lm(pwr~lnx,data = power_test2)
compare<-anova(fit4,fit2,fit3)
if(!is.na(compare$`Pr(>F)`[2]) && compare$`Pr(>F)`[2]<0.05){
j<-polynom::polynomial(coefficients(fit2))
pwr_line<-(solve(j,b = power_target))
if(compare$`Pr(>F)`[3]<0.05){
j<-polynom::polynomial(coefficients(fit3))
pwr_line<-(solve(j,b = power_target))
if(is.complex(pwr_line)){
j<-polynom::polynomial(coefficients(fit2))
pwr_line<-(solve(j,b = power_target)) }
}
if(is.complex(pwr_line)){
j<-polynom::polynomial(coefficients(fit4))
pwr_line<-exp(solve(j,b = power_target))}
} else {
j<-polynom::polynomial(coefficients(fit4))
pwr_line<-exp(solve(j,b = power_target))
}
if(!is.complex(pwr_line)){
pwr_line<-pwr_line[which(pwr_line < max(power_test2$x) & pwr_line> min(power_test2$x))]
if(length(pwr_line)>1){ pwr_line<-pwr_line[1]}
if(length(pwr_line) == 0){
warning("Parameter value is out of data range")
pwr_line<-NA}
} else{pwr_line<-NA}
power_out_final$estimate[p]<-pwr_line
power_out_final
tic()
test_power<-power_interaction(n.iter = 1000,N = seq(20,400,by=20),cl = 6,alpha = 0.05,
r.x1.y = .2,r.x2.y = .1,cr.x1x2.y = c(.18,.2,.22),r.x1.x2 = .2)
toc()
tic()
test_power<-power_interaction(n.iter = 1000,N = seq(20,400,by=20),cl = 6,alpha = 0.05,
r.x1.y = .2,r.x2.y = .1,r.x1x2.y = c(.18,.2,.22),r.x1.x2 = .2)
toc()
power_estimate(power_data = test_power,x = "N",power_target = 0.95)
power_estimate(power_data = test_power,x = "N",power_target = 0.8)
plot_power_curve(power_data = test_power,goal_power = .8)
power_estimate(power_data = test_power,x = "N",power_target = 0.9)
plot_power_curve(power_data = test_power,goal_power = .9)
remove.packages("InteractionPoweR")
.rs.restartR()
setwd("~/InteractionPoweR")
document()
setwd("..")
install("InteractionPoweR")
library(InteractionPoweR)
test_power
power_estimate(power_data = test_power,x = "N",power_target = 0.9)
plot_power_curve(power_data = test_power,goal_power = .9)
plot_simple_slope(power_data = test_power)
152.78 /60
View(test_power)
test_power<-power_interaction(
n.iter = 1000,            # number of simulations per unique combination of input parameters
alpha = 0.05,             # alpha, for the power analysis
N = 350,                  # sample size
r.x1x2.y = .2,            # interaction effect to test (correlation between x1*x2 and y)
r.x1.y = .2,              # correlation between x1 and y
r.x2.y = .1,              # correlation between x2 and y
r.x1.x2 = .2              # correlation between x1 and x2
)
test_power
test_power<-power_interaction(
n.iter = 1000,            # number of simulations per unique combination of input parameters
cl = 6,                   # number of cores for parallel processing (strongly recommended)
alpha = 0.05,             # alpha, for the power analysis
N = 350,                  # sample size
r.x1x2.y = .25,            # interaction effect to test (correlation between x1*x2 and y)
r.x1.y = .2,              # correlation between x1 and y
r.x2.y = .1,              # correlation between x2 and y
r.x1.x2 = .2              # correlation between x1 and x2
)
test_power
test_power<-power_interaction(
n.iter = 1000,            # number of simulations per unique combination of input parameters
cl = 6,                   # number of cores for parallel processing (strongly recommended)
alpha = 0.05,             # alpha, for the power analysis
N = 350,                  # sample size
r.x1x2.y = .15,            # interaction effect to test (correlation between x1*x2 and y)
r.x1.y = .2,              # correlation between x1 and y
r.x2.y = .1,              # correlation between x2 and y
r.x1.x2 = .2              # correlation between x1 and x2
)
test_power
remove.packages("InteractionPoweR")
.rs.restartR()
setwd("~/InteractionPoweR")
document()
setwd("..")
install("InteractionPoweR")
library(InteractionPoweR)
seq(0.06,0.3,by=0.02)
tic()
test_power<-power_interaction(
n.iter = 1000,            # number of simulations per unique combination of input parameters
cl = 6,                   # number of cores for parallel processing (strongly recommended)
alpha = 0.05,             # alpha, for the power analysis
N = 5000             ,    # range of sample sizes to test
r.x1x2.y = seq(0.06,0.3,by=0.02), # range of interaction effects to test
r.x1.y = .2,              # correlation between x1 and y
r.x2.y = .1,              # correlation between x2 and y
r.x1.x2 = .2              # correlation between x1 and x2
)
toc()
plot_simple_slope(power_data = test_power)
test_power<-power_interaction(
n.iter = 1000,            # number of simulations per unique combination of input parameters
cl = 6,                   # number of cores for parallel processing (strongly recommended)
alpha = 0.05,             # alpha, for the power analysis
N = 1000             ,    # range of sample sizes to test
r.x1x2.y = seq(0.06,0.3,by=0.02), # range of interaction effects to test
r.x1.y = .2,              # correlation between x1 and y
r.x2.y = .1,              # correlation between x2 and y
r.x1.x2 = .2              # correlation between x1 and x2
)
plot_simple_slope(power_data = test_power)
test_power
test_power<-power_interaction(
n.iter = 1000,            # number of simulations per unique combination of input parameters
cl = 6,                   # number of cores for parallel processing (strongly recommended)
alpha = 0.05,             # alpha, for the power analysis
N = 500              ,    # sample size
r.x1x2.y = seq(0.06,0.3,
by=0.02), # range of interaction effects to test
r.x1.y = .2,              # correlation between x1 and y
r.x2.y = .1,              # correlation between x2 and y
r.x1.x2 = .2              # correlation between x1 and x2
)
plot_simple_slope(power_data = test_power)
InteractionPoweR can also be useful when trying to determine the smallest effect size of interest for an interaction. We know the population-level correlation between each of our predictors (x1 and x2) and our outcome (y), as well as the correlation between the two predictors. However, we don't know the specific interaction effect size we are interested in. For instance, let us say we are interested in an *attentuated* interaction - one in which the association between x1 and y goes to '0' as a function of x2. What is the smallest effect size that is still an attenuated effect? To find this, we set N to be a value that is large, but still plausible for the analysis, and instead vary r.x1x2.y across a range of values:
test_power
test_power2<-power_interaction(
n.iter = 1000,            # number of simulations per unique combination of input parameters
cl = 6,                   # number of cores for parallel processing (strongly recommended)
alpha = 0.05,             # alpha, for the power analysis
N = seq(300,500,by=20),    # range of sample sizes to test
r.x1x2.y = .16, # range of interaction effects to test
r.x1.y = .2,              # correlation between x1 and y
r.x2.y = .1,              # correlation between x2 and y
r.x1.x2 = .2              # correlation between x1 and x2
)
power_estimate(test_power2,power_target = .9,x = "N")
remove.packages("InteractionPoweR")
.rs.restartR()
setwd("~/InteractionPoweR")
document()
setwd("..")
install("InteractionPoweR")
remove.packages("InteractionPoweR")
.rs.restartR()
setwd("~/InteractionPoweR")
document()
setwd("..")
install("InteractionPoweR")
remove.packages("InteractionPoweR")
.rs.restartR()
setwd("~/InteractionPoweR")
document()
setwd("..")
install("InteractionPoweR")
file.exists("~/.ssh/id_rsa.pub")
