parallel::stopCluster()
stopCluster()
pi
6728/*(4/3)*pi)
6728/((4/3)*pi)
(6728/((4/3)*pi))^(1/3)
round((6728/((4/3)*pi))^(1/3),digits = 0)
floor((6728/((4/3)*pi))^(1/3),digits = 0)
floor((6728/((4/3)*pi))^(1/3))
(4/3)*pi*(floor((6728/((4/3)*pi))^(1/3)))^3
(1-.9)/.9
library(InteractionPoweR)
plot_interaction(generate_interaction(N = 300,r.x1.y = .2,r.x2.y = .2,r.x1x2.y = .2,r.x1.x2 = 0))
plot_interaction(generate_interaction(N = 300,r.x1.y = .2,r.x2.y = -.2,r.x1x2.y = .2,r.x1.x2 = 0))
plot_interaction(generate_interaction(N = 300,r.x1.y = .2,r.x2.y = 0,r.x1x2.y = .2,r.x1.x2 = 0))
plot_interaction(generate_interaction(N = 300,r.x1.y = .2,r.x2.y = 0,r.x1x2.y = .2,r.x1.x2 = 0),q = 3)
setwd("..")
install("InteractionPoweR")
library(roxygen2)
library(devtools)
setwd("~/InteractionPoweR")
setwd("..")
install("InteractionPoweR")
library(InteractionPoweR)
remove.packages("InteractionPoweR")
.rs.restartR()
setwd("~/InteractionPoweR")
document()
setwd("~/InteractionPoweR")
document()
check()
setwd("..")
install("InteractionPoweR")
library(InteractionPoweR)
library(tictoc)
tic()
test_power<-power_interaction(
n.iter = 1000,                  # number of simulations per unique combination of input parameters
cl = 6,                   # number of cores for parallel processing (strongly recommended)
alpha = 0.05,             # alpha, for the power analysis
N = 450,                  # sample size
r.x1x2.y = .15,           # range of interaction effects to test
r.x1.y = .2,              # correlation between x1 and y
r.x2.y = .1,              # correlation between x2 and y
r.x1.x2 = .2,             # correlation between x1 and x2
rel_x1 = seq(.4,1,.2),    # x1 reliability
rel_x2 = seq(.4,1,.2)     # x2 reliability
)
test_power<-power_interaction(
n.iter = 1000,                  # number of simulations per unique combination of input parameters
cl = 6,                   # number of cores for parallel processing (strongly recommended)
alpha = 0.05,             # alpha, for the power analysis
N = 450,                  # sample size
r.x1x2.y = .15,           # range of interaction effects to test
r.x1.y = .2,              # correlation between x1 and y
r.x2.y = .1,              # correlation between x2 and y
r.x1.x2 = .2,             # correlation between x1 and x2
rel_x1 = seq(.4,1,.2),    # x1 reliability
rel_x2 = seq(.4,1,.2)     # x2 reliability
)
toc()
plot_power_curve(test_power,power_target = .9)
test_power
seq(.4,1,.1)
seq(.4,1,.1)
library(tictoc)
tic()
test_power<-power_interaction(
n.iter = 1000,                  # number of simulations per unique combination of input parameters
cl = 6,                   # number of cores for parallel processing (strongly recommended)
alpha = 0.05,             # alpha, for the power analysis
N = 450,                  # sample size
r.x1x2.y = .15,           # range of interaction effects to test
r.x1.y = .2,              # correlation between x1 and y
r.x2.y = .1,              # correlation between x2 and y
r.x1.x2 = .2,             # correlation between x1 and x2
rel_x1 = seq(.4,1,.1),    # x1 reliability
rel_x2 = seq(.4,1,.1)     # x2 reliability
)
toc()
plot_power_curve(test_power,power_target = .9)
library(tictoc)
tic()
test_power<-power_interaction(
n.iter = 10000,                  # number of simulations per unique combination of input parameters
cl = 6,                   # number of cores for parallel processing (strongly recommended)
alpha = 0.05,             # alpha, for the power analysis
N = 450,                  # sample size
r.x1x2.y = .15,           # range of interaction effects to test
r.x1.y = .2,              # correlation between x1 and y
r.x2.y = .1,              # correlation between x2 and y
r.x1.x2 = .2,             # correlation between x1 and x2
rel_x1 = seq(.4,1,.1),    # x1 reliability
rel_x2 = seq(.4,1,.1)     # x2 reliability
)
toc()
plot_power_curve(test_power,power_target = .9)
test_power
library(InteractionPoweR)
test_power<-power_interaction(
n.iter = 1000,            # number of simulations per unique combination of input parameters
cl = 6,                   # number of cores for parallel processing (strongly recommended)
alpha = 0.05,             # alpha, for the power analysis
N = 350,                  # sample size
r.x1x2.y = .15,           # interaction effect to test (correlation between x1*x2 and y)
r.x1.y = .2,              # correlation between x1 and y
r.x2.y = .1,              # correlation between x2 and y
r.x1.x2 = .2              # correlation between x1 and x2
)
n.iter = 1000
cl = 6
alpha = 0.05
N = 350
r.x1x2.y = .15
r.x1.y = .2
r.x2.y = .1
r.x1.x2 = .2
settings<-expand.grid(list( N=N,
r.x1.y = r.x1.y,
r.x2.y = r.x2.y,
r.x1x2.y = r.x1x2.y,
r.x1.x2 = r.x1.x2,
rel_x1=rel_x1,
rel_x2=rel_x2,
rel_y=rel_y,
# sd.x1 = sd.x1,
# sd.x2 = sd.x2,
# sd.y = sd.y,
# mean.x1 = mean.x1,
# mean.x2 = mean.x2,
# mean.y = mean.y,
alpha = alpha,
q = q))
rel_x1=1
rel_x2=1
rel_y=1
alpha=0.05
q=2
s.IQR=1.5
detailed_results=FALSE
full_simulation=FALSE
settings<-expand.grid(list( N=N,
r.x1.y = r.x1.y,
r.x2.y = r.x2.y,
r.x1x2.y = r.x1x2.y,
r.x1.x2 = r.x1.x2,
rel_x1=rel_x1,
rel_x2=rel_x2,
rel_y=rel_y,
# sd.x1 = sd.x1,
# sd.x2 = sd.x2,
# sd.y = sd.y,
# mean.x1 = mean.x1,
# mean.x2 = mean.x2,
# mean.y = mean.y,
alpha = alpha,
q = q))
omit<-NA
i<-NULL
for(i in 1: dim(settings)[1]){
out<-base::tryCatch(expr = {
data<-generate_interaction(N = settings$N[i],
r.x1.y = settings$r.x1.y[i],
r.x2.y = settings$r.x2.y[i],
r.x1x2.y= settings$r.x1x2.y [i],
r.x1.x2  = settings$r.x1.x2[i],
rel_x1=settings$rel_x1[i],
rel_x2=settings$rel_x2[i],
rel_y=settings$rel_y[i]
# mean.x1 = settings$mean.x1[i],
# sd.x1 = settings$sd.x1[i],
# mean.x2 = settings$mean.x2[i],
# sd.x2 = settings$sd.x2[i],
# mean.y = settings$mean.y[i],
# sd.y = settings$sd.y[i]
#sd.x1x2 = settings$sd.x1x2[i],
#r.x1.x1x2=settings$r.x1.x1x2[i],
#r.x2.x1x2=settings$r.x2.x1x2[i],
#binary.x1 = settings$ binary.x1[i],
#binary.x2 = settings$ binary.x2[i]
)
},
warning = function(cond){i},
error = function(cond){i}
)
omit<-c(omit,out)
}
l<-base::lapply(omit, base::is.integer)
bad_ones<-stats::na.omit(base::unlist(omit[l==TRUE]))
if(length(bad_ones) >0){
print(paste(round(length(bad_ones)/dim(settings)[1]*100,2)," % of requested simulations are invalid, n=",length(bad_ones),
". Removing from list.",sep=""))
settings<-settings[-bad_ones,]
if(dim(settings)[1] == 0){
#print()
stop("No valid settings")
}
}
print(paste("Performing",(dim(settings)[1]*n.iter) ,"tests",sep=" "))
# drops<-intersect(colnames(settings),colnames(defaults))
# if(length(drops)>0){defaults<-defaults[,-which(colnames(defaults) == drops)]}
# defaults<-as.list(defaults)
# settings<-expand.grid(c(params,defaults))
settings$N <- round(settings$N )
if(!is.null(cl)){
clus <- parallel::makeCluster(cl)
doParallel::registerDoParallel(clus)
}
i<-NULL
if(dim(settings)[1] > 1){
power_test<-foreach::foreach(i = 1: dim(settings)[1],
.combine = 'rbind',
.packages = c('dplyr','MASS'),
.export=c("test_interaction","generate_interaction")) %dopar% {
out.mat<-sapply(X = c(1:n.iter),FUN = function(X){test_interaction(data =
generate_interaction(N = settings$N[i],
r.x1.y = settings$r.x1.y[i],
r.x2.y = settings$r.x2.y[i],
r.x1x2.y= settings$r.x1x2.y [i],
r.x1.x2  = settings$r.x1.x2[i],
rel_x1=settings$rel_x1[i],
rel_x2=settings$rel_x2[i],
rel_y=settings$rel_y[i]
# mean.x1 = settings$mean.x1[i],
# sd.x1 = settings$sd.x1[i],
# mean.x2 = settings$mean.x2[i],
# sd.x2 = settings$sd.x2[i],
# mean.y = settings$mean.y[i],
# sd.y = settings$sd.y[i]
#sd.x1x2 = settings$sd.x1x2[i],
#r.x1.x1x2=settings$r.x1.x1x2[i],
#r.x2.x1x2=settings$r.x2.x1x2[i],
#binary.x1 = settings$ binary.x1[i],
#binary.x2 = settings$ binary.x2[i]
),
alpha = settings$alpha[i],
q = settings$q[i])})
out.mat<-t(out.mat)
out.mat<-cbind(out.mat,settings[i,],row.names=NULL)
out.cols<-colnames(out.mat)
out.mat<-as.data.frame(matrix(unlist(out.mat),nrow = n.iter))
colnames(out.mat)<-out.cols
return(out.mat)
}
}
if(dim(settings)[1] == 1){
out.mat<-foreach::foreach(i = 1:n.iter,.combine = 'rbind',
.packages = c('dplyr','MASS'),
.export=c("test_interaction","generate_interaction")) %dopar% {
simulation <- test_interaction(data =
generate_interaction(N = settings$N[1],
r.x1.y = settings$r.x1.y[1],
r.x2.y = settings$r.x2.y[1],
r.x1x2.y= settings$r.x1x2.y [1],
r.x1.x2  = settings$r.x1.x2[1],
rel_x1=settings$rel_x1[i],
rel_x2=settings$rel_x2[i],
rel_y=settings$rel_y[i]
# mean.x1 = settings$mean.x1[1],
# sd.x1 = settings$sd.x1[1],
# mean.x2 = settings$mean.x2[1],
# sd.x2 = settings$sd.x2[1],
# mean.y = settings$mean.y[1],
# sd.y = settings$sd.y[1]
#sd.x1x2 = settings$sd.x1x2[1],
#r.x1.x1x2=settings$r.x1.x1x2[1],
#r.x2.x1x2=settings$r.x2.x1x2[1],
#binary.x1 = settings$ binary.x1[1],
#binary.x2 = settings$ binary.x2[1]
),
alpha = settings$alpha[1],
q = settings$q[1])
return(simulation)
}
#out.mat<-t(out.mat)
out.mat<-cbind(out.mat,settings[1,],row.names=NULL)
out.cols<-colnames(out.mat)
out.mat<-as.data.frame(matrix(unlist(out.mat),nrow = n.iter))
colnames(out.mat)<-out.cols
power_test <- out.mat
}
library(foreach)
settings<-expand.grid(list( N=N,
r.x1.y = r.x1.y,
r.x2.y = r.x2.y,
r.x1x2.y = r.x1x2.y,
r.x1.x2 = r.x1.x2,
rel_x1=rel_x1,
rel_x2=rel_x2,
rel_y=rel_y,
# sd.x1 = sd.x1,
# sd.x2 = sd.x2,
# sd.y = sd.y,
# mean.x1 = mean.x1,
# mean.x2 = mean.x2,
# mean.y = mean.y,
alpha = alpha,
q = q))
omit<-NA
i<-NULL
for(i in 1: dim(settings)[1]){
out<-base::tryCatch(expr = {
data<-generate_interaction(N = settings$N[i],
r.x1.y = settings$r.x1.y[i],
r.x2.y = settings$r.x2.y[i],
r.x1x2.y= settings$r.x1x2.y [i],
r.x1.x2  = settings$r.x1.x2[i],
rel_x1=settings$rel_x1[i],
rel_x2=settings$rel_x2[i],
rel_y=settings$rel_y[i]
# mean.x1 = settings$mean.x1[i],
# sd.x1 = settings$sd.x1[i],
# mean.x2 = settings$mean.x2[i],
# sd.x2 = settings$sd.x2[i],
# mean.y = settings$mean.y[i],
# sd.y = settings$sd.y[i]
#sd.x1x2 = settings$sd.x1x2[i],
#r.x1.x1x2=settings$r.x1.x1x2[i],
#r.x2.x1x2=settings$r.x2.x1x2[i],
#binary.x1 = settings$ binary.x1[i],
#binary.x2 = settings$ binary.x2[i]
)
},
warning = function(cond){i},
error = function(cond){i}
)
omit<-c(omit,out)
}
l<-base::lapply(omit, base::is.integer)
bad_ones<-stats::na.omit(base::unlist(omit[l==TRUE]))
if(length(bad_ones) >0){
print(paste(round(length(bad_ones)/dim(settings)[1]*100,2)," % of requested simulations are invalid, n=",length(bad_ones),
". Removing from list.",sep=""))
settings<-settings[-bad_ones,]
if(dim(settings)[1] == 0){
#print()
stop("No valid settings")
}
}
print(paste("Performing",(dim(settings)[1]*n.iter) ,"tests",sep=" "))
# drops<-intersect(colnames(settings),colnames(defaults))
# if(length(drops)>0){defaults<-defaults[,-which(colnames(defaults) == drops)]}
# defaults<-as.list(defaults)
# settings<-expand.grid(c(params,defaults))
settings$N <- round(settings$N )
if(!is.null(cl)){
clus <- parallel::makeCluster(cl)
doParallel::registerDoParallel(clus)
}
i<-NULL
if(dim(settings)[1] > 1){
power_test<-foreach::foreach(i = 1: dim(settings)[1],
.combine = 'rbind',
.packages = c('dplyr','MASS'),
.export=c("test_interaction","generate_interaction")) %dopar% {
out.mat<-sapply(X = c(1:n.iter),FUN = function(X){test_interaction(data =
generate_interaction(N = settings$N[i],
r.x1.y = settings$r.x1.y[i],
r.x2.y = settings$r.x2.y[i],
r.x1x2.y= settings$r.x1x2.y [i],
r.x1.x2  = settings$r.x1.x2[i],
rel_x1=settings$rel_x1[i],
rel_x2=settings$rel_x2[i],
rel_y=settings$rel_y[i]
# mean.x1 = settings$mean.x1[i],
# sd.x1 = settings$sd.x1[i],
# mean.x2 = settings$mean.x2[i],
# sd.x2 = settings$sd.x2[i],
# mean.y = settings$mean.y[i],
# sd.y = settings$sd.y[i]
#sd.x1x2 = settings$sd.x1x2[i],
#r.x1.x1x2=settings$r.x1.x1x2[i],
#r.x2.x1x2=settings$r.x2.x1x2[i],
#binary.x1 = settings$ binary.x1[i],
#binary.x2 = settings$ binary.x2[i]
),
alpha = settings$alpha[i],
q = settings$q[i])})
out.mat<-t(out.mat)
out.mat<-cbind(out.mat,settings[i,],row.names=NULL)
out.cols<-colnames(out.mat)
out.mat<-as.data.frame(matrix(unlist(out.mat),nrow = n.iter))
colnames(out.mat)<-out.cols
return(out.mat)
}
}
if(dim(settings)[1] == 1){
out.mat<-foreach::foreach(i = 1:n.iter,.combine = 'rbind',
.packages = c('dplyr','MASS'),
.export=c("test_interaction","generate_interaction")) %dopar% {
simulation <- test_interaction(data =
generate_interaction(N = settings$N[1],
r.x1.y = settings$r.x1.y[1],
r.x2.y = settings$r.x2.y[1],
r.x1x2.y= settings$r.x1x2.y [1],
r.x1.x2  = settings$r.x1.x2[1],
rel_x1=settings$rel_x1[i],
rel_x2=settings$rel_x2[i],
rel_y=settings$rel_y[i]
# mean.x1 = settings$mean.x1[1],
# sd.x1 = settings$sd.x1[1],
# mean.x2 = settings$mean.x2[1],
# sd.x2 = settings$sd.x2[1],
# mean.y = settings$mean.y[1],
# sd.y = settings$sd.y[1]
#sd.x1x2 = settings$sd.x1x2[1],
#r.x1.x1x2=settings$r.x1.x1x2[1],
#r.x2.x1x2=settings$r.x2.x1x2[1],
#binary.x1 = settings$ binary.x1[1],
#binary.x2 = settings$ binary.x2[1]
),
alpha = settings$alpha[1],
q = settings$q[1])
return(simulation)
}
#out.mat<-t(out.mat)
out.mat<-cbind(out.mat,settings[1,],row.names=NULL)
out.cols<-colnames(out.mat)
out.mat<-as.data.frame(matrix(unlist(out.mat),nrow = n.iter))
colnames(out.mat)<-out.cols
power_test <- out.mat
}
dim(settings)[1] == 1
settings
if(dim(settings)[1] == 1){
out.mat<-foreach::foreach(i = 1:n.iter,.combine = 'rbind',
.packages = c('dplyr','MASS'),
.export=c("test_interaction","generate_interaction")) %dopar% {
simulation <- test_interaction(data =
generate_interaction(N = settings$N[1],
r.x1.y = settings$r.x1.y[1],
r.x2.y = settings$r.x2.y[1],
r.x1x2.y= settings$r.x1x2.y [1],
r.x1.x2  = settings$r.x1.x2[1],
rel_x1=settings$rel_x1[1],
rel_x2=settings$rel_x2[1],
rel_y=settings$rel_y[1]
# mean.x1 = settings$mean.x1[1],
# sd.x1 = settings$sd.x1[1],
# mean.x2 = settings$mean.x2[1],
# sd.x2 = settings$sd.x2[1],
# mean.y = settings$mean.y[1],
# sd.y = settings$sd.y[1]
#sd.x1x2 = settings$sd.x1x2[1],
#r.x1.x1x2=settings$r.x1.x1x2[1],
#r.x2.x1x2=settings$r.x2.x1x2[1],
#binary.x1 = settings$ binary.x1[1],
#binary.x2 = settings$ binary.x2[1]
),
alpha = settings$alpha[1],
q = settings$q[1])
return(simulation)
}
#out.mat<-t(out.mat)
out.mat<-cbind(out.mat,settings[1,],row.names=NULL)
out.cols<-colnames(out.mat)
out.mat<-as.data.frame(matrix(unlist(out.mat),nrow = n.iter))
colnames(out.mat)<-out.cols
power_test <- out.mat
}
remove.packages("InteractionPoweR")
.rs.restartR()
setwd("~/InteractionPoweR")
document()
check()
setwd("..")
install("InteractionPoweR")
library(InteractionPoweR)
library(InteractionPoweR)
test_power<-power_interaction(
n.iter = 1000,            # number of simulations per unique combination of input parameters
cl = 6,                   # number of cores for parallel processing (strongly recommended)
alpha = 0.05,             # alpha, for the power analysis
N = 350,                  # sample size
r.x1x2.y = .15,           # interaction effect to test (correlation between x1*x2 and y)
r.x1.y = .2,              # correlation between x1 and y
r.x2.y = .1,              # correlation between x2 and y
r.x1.x2 = .2              # correlation between x1 and x2
)
test_power
rep(-1,10)
c(rep(-1,10),rep(1,10))
skew(c(rep(-1,10),rep(1,10)))
install.packages("e1071")
e1071::skewness(c(rep(-1,10),rep(1,10)))
var(c(rep(-1,10),rep(1,10)))
var(c(rep(-1,100),rep(1,100)))
var(c(rep(-1,100))
)
var(rnorm(n = 100,mean = 0,sd = 1)
)
var(rnorm(n = 10000,mean = 0,sd = 1))
var(rnorm(n = 100000,mean = 0,sd = 1))
var(rnorm(n = 100000,mean = 0,sd = 1))
var(rnorm(n = 100000,mean = 0,sd = 1))
var(rnorm(n = 100000,mean = 0,sd = 1))
var(rnorm(n = 100000,mean = 0,sd = 1))
var(rnorm(n = 100000,mean = 0,sd = 1))
var(rnorm(n = 100000,mean = 0,sd = 1))
var(rnorm(n = 100000,mean = 0,sd = 1))
var(rnorm(n = 100000,mean = 0,sd = 1))
var(rnorm(n = 100000,mean = 0,sd = 1))
var(rnorm(n = 100000,mean = 0,sd = 1))
var(rnorm(n = 100000,mean = 0,sd = 1))
var(rnorm(n = 100000,mean = 0,sd = 1))
var(rnorm(n = 100000,mean = 0,sd = 1))
e1071::skewness(c(rep(-1,10),rep(1,10)))
e1071::skewness(c(rep(-1,1000),rep(1,1000)))
var(c(rep(-1,1000),rep(1,1000)))
install.packages("PoisNonNor")
rmat = matrix(c(-0.5486,-0.2103, 0.3386, 0.9035, 1.0283, 0.9272), byrow=TRUE, ncol=2)
PoisNonNor::Param.fleishman(rmat)
